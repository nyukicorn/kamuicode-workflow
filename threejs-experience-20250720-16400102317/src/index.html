<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Áæé„Åó„ÅÑv4‰øÆÊ≠£Áâà„ÉÜ„Çπ„Éà - Three.js 3D Art Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            display: block;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        #ui h3 {
            margin-bottom: 10px;
            color: #fff;
            font-size: 16px;
        }

        #ui p {
            margin: 5px 0;
            font-size: 12px;
            color: #ccc;
        }

        #color-controls {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(15px);
            opacity: 0.3;
            transition: opacity 0.3s ease;
            width: 200px;
        }

        #color-controls:hover {
            opacity: 1;
        }

        #color-controls h4 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 14px;
            text-align: center;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 11px;
            color: #ccc;
            margin-bottom: 5px;
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: #fff;
            font-size: 11px;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .slider-value {
            font-size: 10px;
            color: #aaa;
            text-align: center;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
        }

        .hidden {
            display: none;
        }

        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            padding: 20px;
            border-radius: 10px;
            color: #fff;
            text-align: center;
            max-width: 400px;
        }

        @media (max-width: 768px) {
            #ui {
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 10px;
            }

            #color-controls {
                right: 10px;
                width: 150px;
                padding: 15px;
            }

            #color-controls h4 {
                font-size: 12px;
            }

            .control-group label {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="loading">
            <h2>Loading 3D Experience...</h2>
            <p>Please wait while we prepare your beautiful art experience</p>
        </div>

        <div id="error" class="hidden">
            <h3>Error</h3>
            <p id="error-message"></p>
        </div>

        <div id="ui">
            <h3>Áæé„Åó„ÅÑv4‰øÆÊ≠£Áâà„ÉÜ„Çπ„Éà</h3>
            <p>üñ±Ô∏è „Éû„Ç¶„Çπ„Éâ„É©„ÉÉ„Ç∞: Ë¶ñÁÇπÁßªÂãï</p>
            <p>üîÑ „Éõ„Ç§„Éº„É´: „Ç∫„Éº„É†</p>
            <p>‚ö° „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ: Ëá™ÂãïÂõûËª¢</p>
            <p>üé® Âè≥ÂÅ¥: Ëâ≤Â§âÊõ¥„Ç≥„É≥„Éà„É≠„Éº„É´</p>
        </div>

        <div id="color-controls">
            <h4>üé® „Éë„Éº„ÉÜ„Ç£„ÇØ„É´Âà∂Âæ°</h4>
            
            <div class="control-group">
                <label>Ëâ≤„É¢„Éº„Éâ</label>
                <select id="color-mode">
                    <option value="single">ÂçòËâ≤</option>
                    <option value="gradient" selected>„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥</option>
                    <option value="rainbow">„É¨„Ç§„É≥„Éú„Éº</option>
                </select>
            </div>

            <div class="control-group">
                <label>„Éô„Éº„ÇπËâ≤</label>
                <input type="color" id="base-color" value="#ffffff">
            </div>

            <div class="control-group">
                <label>ÂõûËª¢ÈÄüÂ∫¶</label>
                <input type="range" id="rotation-speed" min="0.001" max="0.05" step="0.001" value="0.01">
                <div class="slider-value" id="rotation-value">0.01</div>
            </div>

            <div class="control-group">
                <label>„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„Çµ„Ç§„Ç∫</label>
                <input type="range" id="particle-size" min="0.1" max="3.0" step="0.1" value="0.3">
                <div class="slider-value" id="size-value">0.3</div>
            </div>

            <div class="control-group">
                <label>„Éë„Éº„ÉÜ„Ç£„ÇØ„É´Êï∞</label>
                <input type="range" id="particle-count" min="100" max="5000" step="100" value="50">
                <div class="slider-value" id="count-value">50</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, particles;
        let isAutoRotating = false;
        let autoRotationSpeed = 0.01;
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let cameraRotationX = 0, cameraRotationY = 0;
        let particleColors = [];
        let particleGeometry, particleMaterial;

        // Check WebGL support
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && 
                         canvas.getContext('webgl')) ||
                       !!(window.WebGL2RenderingContext && 
                         canvas.getContext('webgl2'));
            } catch (e) {
                return false;
            }
        }

        // Show error message
        function showError(message) {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error-message').textContent = message;
            document.getElementById('error').classList.remove('hidden');
        }

        // Create star geometry
        function createStarGeometry(size = 0.3) {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            // Star shape with 5 points
            const outerRadius = size;
            const innerRadius = size * 0.4;
            const spikes = 5;
            
            for (let i = 0; i < spikes * 2; i++) {
                const angle = (i / (spikes * 2)) * Math.PI * 2;
                const radius = (i % 2 === 0) ? outerRadius : innerRadius;
                
                vertices.push(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            return geometry;
        }

        // Create particle system
        function createParticles(count = 50, size = 0.3) {
            if (particles) {
                scene.remove(particles);
            }

            const positions = [];
            particleColors = [];
            
            for (let i = 0; i < count; i++) {
                // Random position in sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const radius = 5 + Math.random() * 10;
                
                positions.push(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
                
                // Default white color
                particleColors.push(1, 1, 1);
            }
            
            particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
            
            particleMaterial = new THREE.PointsMaterial({
                size: size,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            updateParticleColors();
        }

        // Update particle colors based on mode
        function updateParticleColors() {
            if (!particleGeometry) return;
            
            const colorMode = document.getElementById('color-mode').value;
            const baseColor = new THREE.Color(document.getElementById('base-color').value);
            const colors = particleGeometry.attributes.color;
            
            for (let i = 0; i < colors.count; i++) {
                let color;
                
                switch (colorMode) {
                    case 'single':
                        color = baseColor;
                        break;
                    case 'gradient':
                        // Same hue, varying lightness
                        const hsl = {};
                        baseColor.getHSL(hsl);
                        const lightness = 0.3 + Math.random() * 0.7;
                        color = new THREE.Color().setHSL(hsl.h, hsl.s, lightness);
                        break;
                    case 'rainbow':
                        // Different hues
                        const hue = Math.random();
                        color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                        break;
                }
                
                colors.setXYZ(i, color.r, color.g, color.b);
            }
            
            colors.needsUpdate = true;
        }

        // Initialize 3D scene
        function init() {
            if (!checkWebGLSupport()) {
                showError('WebGL„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Å™„ÅÑ„Éñ„É©„Ç¶„Ç∂„Åß„Åô„ÄÇÊúÄÊñ∞„ÅÆ„Éñ„É©„Ç¶„Ç∂„Çí„ÅîÂà©Áî®„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }

            try {
                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000); // Solid black background
                
                // Camera setup
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 15);
                
                // Renderer setup
                const canvas = document.getElementById('canvas');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true,
                    alpha: false
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Create particles
                createParticles(50, 0.3);
                
                // Add ambient lighting for better visual
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
                scene.add(ambientLight);
                
                // Setup controls
                setupControls();
                
                // Setup UI
                setupUI();
                
                // Start animation
                animate();
                
                // Hide loading
                document.getElementById('loading').classList.add('hidden');
                
            } catch (error) {
                showError('3DÁí∞Â¢É„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
            }
        }

        // Setup mouse and touch controls
        function setupControls() {
            const canvas = document.getElementById('canvas');
            
            // Mouse events
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            canvas.addEventListener('wheel', onWheel, false);
            canvas.addEventListener('dblclick', onDoubleClick, false);
            
            // Touch events
            canvas.addEventListener('touchstart', onTouchStart, false);
            canvas.addEventListener('touchmove', onTouchMove, false);
            canvas.addEventListener('touchend', onTouchEnd, false);
            
            // Prevent context menu
            canvas.addEventListener('contextmenu', e => e.preventDefault(), false);
        }

        // Mouse event handlers
        function onMouseDown(event) {
            mouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
            document.getElementById('canvas').style.cursor = 'grabbing';
        }

        function onMouseMove(event) {
            if (!mouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            cameraRotationY += deltaX * 0.01;
            cameraRotationX += deltaY * 0.01;
            
            // Limit vertical rotation
            cameraRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotationX));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
            
            updateCameraPosition();
        }

        function onMouseUp() {
            mouseDown = false;
            document.getElementById('canvas').style.cursor = 'grab';
        }

        function onWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.1;
            camera.position.multiplyScalar(1 + (event.deltaY > 0 ? zoomSpeed : -zoomSpeed));
            
            // Limit zoom
            const distance = camera.position.length();
            if (distance < 5) camera.position.normalize().multiplyScalar(5);
            if (distance > 50) camera.position.normalize().multiplyScalar(50);
        }

        function onDoubleClick() {
            isAutoRotating = !isAutoRotating;
        }

        // Touch event handlers
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseDown = true;
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && mouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;
                
                cameraRotationY += deltaX * 0.01;
                cameraRotationX += deltaY * 0.01;
                
                cameraRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotationX));
                
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                
                updateCameraPosition();
            }
        }

        function onTouchEnd() {
            mouseDown = false;
        }

        // Update camera position based on rotation
        function updateCameraPosition() {
            const distance = camera.position.length();
            camera.position.x = distance * Math.sin(cameraRotationY) * Math.cos(cameraRotationX);
            camera.position.y = distance * Math.sin(cameraRotationX);
            camera.position.z = distance * Math.cos(cameraRotationY) * Math.cos(cameraRotationX);
            camera.lookAt(0, 0, 0);
        }

        // Setup UI controls
        function setupUI() {
            // Color mode change
            document.getElementById('color-mode').addEventListener('change', updateParticleColors);
            document.getElementById('base-color').addEventListener('input', updateParticleColors);
            
            // Rotation speed
            const rotationSlider = document.getElementById('rotation-speed');
            const rotationValue = document.getElementById('rotation-value');
            rotationSlider.addEventListener('input', function() {
                autoRotationSpeed = parseFloat(this.value);
                rotationValue.textContent = this.value;
            });
            
            // Particle size
            const sizeSlider = document.getElementById('particle-size');
            const sizeValue = document.getElementById('size-value');
            sizeSlider.addEventListener('input', function() {
                if (particleMaterial) {
                    particleMaterial.size = parseFloat(this.value);
                }
                sizeValue.textContent = this.value;
            });
            
            // Particle count
            const countSlider = document.getElementById('particle-count');
            const countValue = document.getElementById('count-value');
            countSlider.addEventListener('input', function() {
                const newCount = parseInt(this.value);
                const currentSize = particleMaterial ? particleMaterial.size : 0.3;
                createParticles(newCount, currentSize);
                countValue.textContent = this.value;
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Auto rotation
            if (isAutoRotating) {
                cameraRotationY += autoRotationSpeed;
                updateCameraPosition();
            }
            
            // Rotate particles
            if (particles) {
                particles.rotation.y += 0.005;
                particles.rotation.x += 0.002;
            }
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize, false);

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>