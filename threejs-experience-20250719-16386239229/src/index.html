<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>花園パノラマ体験 - Three.js VR Experience</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
            user-select: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
        }
        
        .control-btn:active {
            background: rgba(200, 200, 200, 1);
        }
        
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            text-align: center;
            background: rgba(255, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            text-align: center;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <h2>花園パノラマ読み込み中...</h2>
            <p>Please wait while loading the flower garden panorama...</p>
        </div>
        
        <div id="error">
            <h2>WebGL Error</h2>
            <p>Your browser does not support WebGL or it is disabled.</p>
        </div>
        
        <div id="info">
            <div>🌸 花園パノラマ体験</div>
            <div>マウス: ドラッグで視点移動</div>
            <div>ホイール: ズーム</div>
            <div>ダブルクリック: 自動回転</div>
            <div>タッチ: 指でドラッグ/ピンチ</div>
        </div>
        
        <div id="controls">
            <button class="control-btn" id="musicBtn">🎵 音楽 ON</button>
            <button class="control-btn" id="autoRotateBtn">🔄 自動回転</button>
            <button class="control-btn" id="resetBtn">🏠 リセット</button>
        </div>
        
        <audio id="bgMusic" loop preload="auto">
            <source src="generated-music.wav" type="audio/wav">
        </audio>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class FlowerGardenExperience {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.sphere = null;
                this.particles = null;
                this.isAutoRotating = false;
                this.isUserInteracting = false;
                this.isMusicPlaying = false;
                
                // Mouse control variables
                this.mouseX = 0;
                this.mouseY = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.mouseSpeed = 0.002;
                
                // Touch control variables
                this.touchX = 0;
                this.touchY = 0;
                this.targetTouchX = 0;
                this.targetTouchY = 0;
                
                // Camera limits
                this.phi = 0;
                this.theta = 0;
                this.radius = 1;
                this.minRadius = 0.1;
                this.maxRadius = 10;
                
                this.init();
            }
            
            init() {
                if (!this.checkWebGL()) {
                    document.getElementById('error').style.display = 'block';
                    document.getElementById('loading').style.display = 'none';
                    return;
                }
                
                this.setupScene();
                this.setupCamera();
                this.setupRenderer();
                this.loadPanorama();
                this.createParticles();
                this.setupControls();
                this.setupEventListeners();
                this.animate();
            }
            
            checkWebGL() {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext && 
                            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                } catch (e) {
                    return false;
                }
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
            }
            
            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 0, 0);
            }
            
            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('container').appendChild(this.renderer.domElement);
            }
            
            loadPanorama() {
                const loader = new THREE.TextureLoader();
                loader.load(
                    'panorama.jpg',
                    (texture) => {
                        const geometry = new THREE.SphereGeometry(500, 60, 40);
                        geometry.scale(-1, 1, 1);
                        
                        const material = new THREE.MeshBasicMaterial({
                            map: texture
                        });
                        
                        this.sphere = new THREE.Mesh(geometry, material);
                        this.scene.add(this.sphere);
                        
                        document.getElementById('loading').style.display = 'none';
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        document.getElementById('loading').innerHTML = 
                            `<h2>花園パノラマ読み込み中... ${percent}%</h2>`;
                    },
                    (error) => {
                        console.error('Panorama loading error:', error);
                        document.getElementById('loading').innerHTML = 
                            '<h2>パノラマ読み込みエラー</h2><p>panorama.jpgが見つかりません</p>';
                    }
                );
            }
            
            createParticles() {
                const particleCount = 1000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Random position in sphere
                    const radius = Math.random() * 400 + 50;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.cos(phi);
                    positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                    
                    // Flower-like colors
                    const colorChoice = Math.random();
                    if (colorChoice < 0.3) {
                        colors[i3] = 1.0; colors[i3 + 1] = 0.5; colors[i3 + 2] = 0.8; // Pink
                    } else if (colorChoice < 0.6) {
                        colors[i3] = 1.0; colors[i3 + 1] = 1.0; colors[i3 + 2] = 0.0; // Yellow
                    } else {
                        colors[i3] = 1.0; colors[i3 + 1] = 0.2; colors[i3 + 2] = 0.2; // Red
                    }
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }
            
            setupControls() {
                const musicBtn = document.getElementById('musicBtn');
                const autoRotateBtn = document.getElementById('autoRotateBtn');
                const resetBtn = document.getElementById('resetBtn');
                const bgMusic = document.getElementById('bgMusic');
                
                musicBtn.addEventListener('click', () => {
                    if (this.isMusicPlaying) {
                        bgMusic.pause();
                        musicBtn.textContent = '🎵 音楽 ON';
                        this.isMusicPlaying = false;
                    } else {
                        bgMusic.play().catch(e => console.log('Music play failed:', e));
                        musicBtn.textContent = '🔇 音楽 OFF';
                        this.isMusicPlaying = true;
                    }
                });
                
                autoRotateBtn.addEventListener('click', () => {
                    this.isAutoRotating = !this.isAutoRotating;
                    autoRotateBtn.textContent = this.isAutoRotating ? '⏸️ 停止' : '🔄 自動回転';
                });
                
                resetBtn.addEventListener('click', () => {
                    this.resetCamera();
                    this.isAutoRotating = false;
                    autoRotateBtn.textContent = '🔄 自動回転';
                });
                
                // Volume control
                bgMusic.volume = 0.5;
            }
            
            setupEventListeners() {
                const canvas = this.renderer.domElement;
                
                // Mouse events
                canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                canvas.addEventListener('wheel', this.onMouseWheel.bind(this));
                canvas.addEventListener('dblclick', this.onDoubleClick.bind(this));
                
                // Touch events
                canvas.addEventListener('touchstart', this.onTouchStart.bind(this));
                canvas.addEventListener('touchmove', this.onTouchMove.bind(this));
                canvas.addEventListener('touchend', this.onTouchEnd.bind(this));
                
                // Window resize
                window.addEventListener('resize', this.onWindowResize.bind(this));
                
                // Prevent context menu
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            onMouseDown(event) {
                this.isUserInteracting = true;
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
            }
            
            onMouseMove(event) {
                if (!this.isUserInteracting) return;
                
                const deltaX = event.clientX - this.mouseX;
                const deltaY = event.clientY - this.mouseY;
                
                this.targetX += deltaX * this.mouseSpeed;
                this.targetY += deltaY * this.mouseSpeed;
                
                this.targetY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.targetY));
                
                this.mouseX = event.clientX;
                this.mouseY = event.clientY;
            }
            
            onMouseUp() {
                this.isUserInteracting = false;
            }
            
            onMouseWheel(event) {
                event.preventDefault();
                this.radius += event.deltaY * 0.01;
                this.radius = Math.max(this.minRadius, Math.min(this.maxRadius, this.radius));
            }
            
            onTouchStart(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    this.isUserInteracting = true;
                    this.touchX = event.touches[0].clientX;
                    this.touchY = event.touches[0].clientY;
                }
            }
            
            onTouchMove(event) {
                event.preventDefault();
                if (!this.isUserInteracting || event.touches.length !== 1) return;
                
                const deltaX = event.touches[0].clientX - this.touchX;
                const deltaY = event.touches[0].clientY - this.touchY;
                
                this.targetX += deltaX * this.mouseSpeed;
                this.targetY += deltaY * this.mouseSpeed;
                
                this.targetY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.targetY));
                
                this.touchX = event.touches[0].clientX;
                this.touchY = event.touches[0].clientY;
            }
            
            onTouchEnd(event) {
                event.preventDefault();
                this.isUserInteracting = false;
            }
            
            onDoubleClick() {
                this.isAutoRotating = !this.isAutoRotating;
                const autoRotateBtn = document.getElementById('autoRotateBtn');
                autoRotateBtn.textContent = this.isAutoRotating ? '⏸️ 停止' : '🔄 自動回転';
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            resetCamera() {
                this.targetX = 0;
                this.targetY = 0;
                this.radius = 1;
            }
            
            updateCamera() {
                if (this.isAutoRotating && !this.isUserInteracting) {
                    this.targetX += 0.01;
                }
                
                // Smooth camera movement
                this.phi += (this.targetY - this.phi) * 0.1;
                this.theta += (this.targetX - this.theta) * 0.1;
                
                const x = this.radius * Math.sin(this.phi) * Math.cos(this.theta);
                const y = this.radius * Math.cos(this.phi);
                const z = this.radius * Math.sin(this.phi) * Math.sin(this.theta);
                
                this.camera.position.set(x, y, z);
                this.camera.lookAt(0, 0, 0);
            }
            
            updateParticles() {
                if (this.particles) {
                    const time = Date.now() * 0.001;
                    const speed = this.isAutoRotating ? 2 : 1;
                    this.particles.rotation.y = time * 0.1 * speed;
                    this.particles.rotation.x = Math.sin(time * 0.2) * 0.05;
                }
            }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                this.updateCamera();
                this.updateParticles();
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Start the experience when page loads
        window.addEventListener('load', () => {
            new FlowerGardenExperience();
        });
    </script>
</body>
</html>